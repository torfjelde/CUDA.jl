<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Troubleshooting · CUDA.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-154489943-2', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://juliagpu.github.io/CUDA.jl/stable/development/troubleshooting/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="CUDA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">CUDA.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/introduction/">Introduction</a></li></ul></li><li><span class="tocitem">Installation</span><ul><li><a class="tocitem" href="../../installation/overview/">Overview</a></li><li><a class="tocitem" href="../../installation/conditional/">Conditional use</a></li><li><a class="tocitem" href="../../installation/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../../usage/overview/">Overview</a></li><li><a class="tocitem" href="../../usage/workflow/">Workflow</a></li><li><a class="tocitem" href="../../usage/array/">Array programming</a></li><li><a class="tocitem" href="../../usage/memory/">Memory management</a></li><li><a class="tocitem" href="../../usage/multigpu/">Multiple GPUs</a></li></ul></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../profiling/">Profiling</a></li><li class="is-active"><a class="tocitem" href>Troubleshooting</a><ul class="internal"><li><a class="tocitem" href="#InvalidIRError:-compiling-...-resulted-in-invalid-LLVM-IR"><span>InvalidIRError: compiling ... resulted in invalid LLVM IR</span></a></li><li><a class="tocitem" href="#KernelError:-kernel-returns-a-value-of-type-Union{}"><span>KernelError: kernel returns a value of type <code>Union{}</code></span></a></li><li><a class="tocitem" href="#Debug-info-and-line-number-information"><span>Debug info and line-number information</span></a></li><li><a class="tocitem" href="#Stack-trace-information"><span>Stack trace information</span></a></li></ul></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../../api/essentials/">Essentials</a></li><li><a class="tocitem" href="../../api/compiler/">Compiler</a></li><li><a class="tocitem" href="../../api/kernel/">Kernel programming</a></li><li><a class="tocitem" href="../../api/array/">Array programming</a></li></ul></li><li><span class="tocitem">Library reference</span><ul><li><a class="tocitem" href="../../lib/driver/">CUDA driver</a></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Development</a></li><li class="is-active"><a href>Troubleshooting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Troubleshooting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGPU/CUDA.jl/blob/master/docs/src/development/troubleshooting.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Troubleshooting"><a class="docs-heading-anchor" href="#Troubleshooting">Troubleshooting</a><a id="Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting" title="Permalink"></a></h1><p>To increase logging verbosity of the CUDA.jl compiler, launch Julia with the <code>JULIA_DEBUG</code> environment variable set to <code>CUDA</code>.</p><h2 id="InvalidIRError:-compiling-...-resulted-in-invalid-LLVM-IR"><a class="docs-heading-anchor" href="#InvalidIRError:-compiling-...-resulted-in-invalid-LLVM-IR">InvalidIRError: compiling ... resulted in invalid LLVM IR</a><a id="InvalidIRError:-compiling-...-resulted-in-invalid-LLVM-IR-1"></a><a class="docs-heading-anchor-permalink" href="#InvalidIRError:-compiling-...-resulted-in-invalid-LLVM-IR" title="Permalink"></a></h2><p>Not all of Julia is supported by CUDA.jl. Several commonly-used features, like strings or exceptions, will not compile to GPU code, because of their interactions with the CPU-only runtime library.</p><p>For example, say we define and try to execute the following kernel:</p><pre><code class="language-julia">julia&gt; function kernel(a)
         @inbounds a[threadId().x] = 0
         return
       end

julia&gt; @cuda kernel(CuArray([1]))
ERROR: InvalidIRError: compiling kernel kernel(CuDeviceArray{Int64,1,1}) resulted in invalid LLVM IR
Reason: unsupported dynamic function invocation (call to setindex!)
Stacktrace:
 [1] kernel at REPL[2]:2
Reason: unsupported dynamic function invocation (call to getproperty)
Stacktrace:
 [1] kernel at REPL[2]:2
Reason: unsupported use of an undefined name (use of &#39;threadId&#39;)
Stacktrace:
 [1] kernel at REPL[2]:2</code></pre><p>CUDA.jl does its best to decode the unsupported IR and figure out where it came from. In this case, there&#39;s two so-called dynamic invocations, which happen when a function call cannot be statically resolved (often because the compiler could not fully infer the call, e.g., due to inaccurate or instable type information). These are a red herring, and the real cause is listed last: a typo in the use of the <code>threadIdx</code> function! If we fix this, the IR error disappears and our kernel successfully compiles and executes.</p><h2 id="KernelError:-kernel-returns-a-value-of-type-Union{}"><a class="docs-heading-anchor" href="#KernelError:-kernel-returns-a-value-of-type-Union{}">KernelError: kernel returns a value of type <code>Union{}</code></a><a id="KernelError:-kernel-returns-a-value-of-type-Union{}-1"></a><a class="docs-heading-anchor-permalink" href="#KernelError:-kernel-returns-a-value-of-type-Union{}" title="Permalink"></a></h2><p>Where the previous section clearly pointed to the source of invalid IR, in other cases your function will return an error. This is encoded by the Julia compiler as a return value of type <code>Union{}</code>:</p><pre><code class="language-julia">julia&gt; function kernel(a)
         @inbounds a[threadId().x] = CUDA.sin(a[threadIdx().x])
         return
       end

julia&gt; @cuda kernel(CuArray([1]))
ERROR: GPU compilation of kernel kernel(CuDeviceArray{Int64,1,1}) failed
KernelError: kernel returns a value of type `Union{}`</code></pre><p>Now we don&#39;t know where this error came from, and we will have to take a look ourselves at the generated code. This is easily done using the <code>@device_code</code> introspection macros, which mimic their Base counterparts (e.g. <code>@device_code_llvm</code> instead of <code>@code_llvm</code>, etc).</p><p>To debug an error returned by a kernel, we should use <code>@device_code_warntype</code> to inspect the Julia IR. Furthermore, this macro has an <code>interactive</code> mode, which further facilitates inspecting this IR using Cthulhu.jl. First, install and import this package, and then try to execute the kernel again prefixed by <code>@device_code_warntype interactive=true</code>:</p><pre><code class="language-julia">julia&gt; using Cthulhu

julia&gt; @device_code_warntype interactive=true @cuda kernel(CuArray([1]))
Variables
  #self#::Core.Compiler.Const(kernel, false)
  a::CuDeviceArray{Int64,1,1}
  val::Union{}

Body::Union{}
1 ─ %1  = CUDA.sin::Core.Compiler.Const(CUDA.sin, false)
│   ...
│   %14 = (...)::Int64
└──       goto #2
2 ─       (%1)(%14)
└──       $(Expr(:unreachable))

Select a call to descend into or ↩ to ascend.
 • %17  = call CUDA.sin(::Int64)::Union{}</code></pre><p>Both from the IR and the list of calls Cthulhu offers to inspect further, we can see that the call to <code>CUDA.sin(::Int64)</code> results in an error: in the IR it is immediately followed by an <code>unreachable</code>, while in the list of calls it is inferred to return <code>Union{}</code>. Now we know where to look, it&#39;s easy to figure out what&#39;s wrong:</p><pre><code class="language-julia">help?&gt; CUDA.sin
  # 2 methods for generic function &quot;sin&quot;:
  [1] sin(x::Float32) in CUDA at /home/tim/Julia/pkg/CUDA/src/device/intrinsics/math.jl:13
  [2] sin(x::Float64) in CUDA at /home/tim/Julia/pkg/CUDA/src/device/intrinsics/math.jl:12</code></pre><p>There&#39;s no method of <code>CUDA.sin</code> that accepts an Int64, and thus the function was determined to unconditionally throw a method error. For now, we disallow these situations and refuse to compile, but in the spirit of dynamic languages we might change this behavior to just throw an error at run time.</p><h2 id="Debug-info-and-line-number-information"><a class="docs-heading-anchor" href="#Debug-info-and-line-number-information">Debug info and line-number information</a><a id="Debug-info-and-line-number-information-1"></a><a class="docs-heading-anchor-permalink" href="#Debug-info-and-line-number-information" title="Permalink"></a></h2><p>On Julia debug level 1, which is the default setting if unspecified, CUDA.jl emits line number information corresponding to <code>nvcc -lineinfo</code>. This information does not hurt performance, and is used by a variety of tools to improve the debugging experience.</p><p>To emit actual debug info as <code>nvcc -G</code> does, you need to start Julia on debug level 2 by passing the flag <code>-g2</code>. Support for emitting PTX-compatible debug info is a recent addition to the NVPTX LLVM back-end, so it&#39;s possible this information is incorrect or otherwise affects compilation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Due to bugs in LLVM and/or CUDA, the debug info as emitted by LLVM 8.0 or higher results in crashed when loading the compiled code. As a result, all types of debug info are disabled by CUDA.jl on Julia 1.4 or above. If you need line number information, you need to revert to using Julia 1.3 which uses LLVM 6.0 (note that actual debug info is not supported by LLVM 6.0).</p></div></div><p>To disable all debug info emission, start Julia with the flag <code>-g0</code>.</p><h2 id="Stack-trace-information"><a class="docs-heading-anchor" href="#Stack-trace-information">Stack trace information</a><a id="Stack-trace-information-1"></a><a class="docs-heading-anchor-permalink" href="#Stack-trace-information" title="Permalink"></a></h2><p>The Julia debug level is also used to emit determine how much backtrace information to embed in the module. This information is used when displaying exceptions on the device, e.g., when going out of bounds:</p><pre><code class="language-julia">julia&gt; function kernel(a)
         a[threadIdx().x] = 0
         return
       end
kernel (generic function with 1 method)

julia&gt; @cuda threads=2 kernel(CuArray([1]))</code></pre><p>On the default debug level of 1, an simple error message will be displayed:</p><pre><code class="language-none">ERROR: a exception was thrown during kernel execution.
Run Julia on debug level 2 for device stack traces.</code></pre><p>If we set the debug level to 2, by passing <code>-g2</code> to <code>julia</code>, we see:</p><pre><code class="language-none">ERROR: a exception was thrown during kernel execution.
Stacktrace:
 [1] throw_boundserror at abstractarray.jl:541
 [2] checkbounds at abstractarray.jl:506
 [3] arrayset at /home/tim/Julia/pkg/CUDA/src/device/array.jl:84
 [4] setindex! at /home/tim/Julia/pkg/CUDA/src/device/array.jl:101
 [5] kernel at REPL[4]:2</code></pre><p>Note that these messages are embedded in the module (CUDA does not support stack unwinding), and thus bloat its size. To avoid any overhead, you can disable these messages by setting the debug level to 0 (passing <code>-g0</code> to <code>julia</code>). This disabled any device-side message, but retains the host-side detection:</p><pre><code class="language-none">julia&gt; @cuda threads=2 kernel(CuArray([1]))
# no device-side error message!

julia&gt; synchronize()
ERROR: KernelException: exception thrown during kernel execution</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../profiling/">« Profiling</a><a class="docs-footer-nextpage" href="../../api/essentials/">Essentials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 12 February 2021 16:23">Friday 12 February 2021</span>. Using Julia version 1.6.0-rc1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
